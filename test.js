const { google } = require("googleapis");
const fs = require("fs");
const readline = require("readline");
const credentials = require("./credentials.json");
const SCOPES = [
    "https://www.googleapis.com/auth/gmail.modify",
    "https://www.googleapis.com/auth/drive.file",
];

// Create an OAuth2 client
const { client_secret, client_id, redirect_uris } = credentials.web;
const oAuth2Client = new google.auth.OAuth2(
    client_id,
    client_secret,
    redirect_uris[0],
);

// Authorize the client
function authorize() {
    return new Promise((resolve, reject) => {
        const authUrl = oAuth2Client.generateAuthUrl({
            access_type: "offline",
            scope: SCOPES,
        });

        console.log("Authorize this app by visiting this URL:", authUrl);

        const rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout,
        });

        rl.question("Enter the code from the authorization page: ", (code) => {
            rl.close();
            oAuth2Client.getToken(code, (err, token) => {
                if (err) {
                    console.error("Error retrieving access token:", err);
                    reject(err);
                } else {
                    oAuth2Client.setCredentials(token);
                    resolve();
                }
            });
        });
    });
}

async function checkEmails() {
    const gmail = google.gmail({ version: "v1", auth: oAuth2Client });

    try {
        const response = await gmail.users.threads.list({
            userId: "me",
            q: "is:unread",
        });

        const threads = response.data.threads;
        if (threads && threads.length > 0) {
            console.log("You have unread emails!");
            for (let i = 0; i < threads.length; i++) {
                const thread = await gmail.users.threads.get({
                    userId: "me",
                    id: threads[i].id,
                });

                const hasReplies = thread.data.messages.some((message) =>
                    message.payload.headers.some(
                        (header) =>
                            header.name === "From" &&
                            header.value === "dgaur20102002@gmail.com",
                    ),
                );

                if (!hasReplies) {
                    console.log(
                        "Replying to the email thread:",
                        thread.data.id,
                    );
                    await replyToEmail(gmail, thread.data.id);
                }
            }
        } else {
            console.log("No unread emails.");
        }
    } catch (err) {
        console.error("Error checking emails:", err);
    }
}

// Reply to an email
async function replyToEmail(gmail, messageId) {
    const emailContent = `This is a test app autogenerated mail.`;

    const originalMessage = await gmail.users.messages.get({
        userId: "me",
        id: messageId,
    });

    const recipient = originalMessage.data.payload.headers.find(
        (header) => header.name === "From",
    ).value;

    const rawEmail = makeRawEmail(recipient, messageId, emailContent);

    try {

        await gmail.users.messages.send({
            userId: "me",
            resource: {
                raw: rawEmail,
                threadId: messageId,
            },
        });

        // Create a label (if it doesn't exist already)
        const labelName = "test";
        const label = await createLabel(gmail, labelName);

        // Move the email to the labeled folder
        await moveEmailToLabel(gmail, messageId, label.id);

        console.log("Reply sent and email moved to the label:", labelName);
    } catch (err) {
        console.error("Error replying to email:", err);
    }
}

// Create a label or retrieve existing label with the same name
async function createLabel(gmail, labelName) {
    try {
        const response = await gmail.users.labels.list({ userId: "me" });

        const existingLabel = response.data.labels.find(
            (label) => label.name === labelName,
        );
        if (existingLabel) {
            return existingLabel;
        }

        const createResponse = await gmail.users.labels.create({
            userId: "me",
            resource: {
                name: labelName,
                labelListVisibility: "labelShow",
                messageListVisibility: "show",
            },
        });

        return createResponse.data;
    } catch (err) {
        console.error("Error creating or retrieving label:", err);
        throw err;
    }
}

// Move an email to a label
async function moveEmailToLabel(gmail, messageId, labelId) {
    try {
        await gmail.users.messages.modify({
            userId: "me",
            id: messageId,
            resource: {
                addLabelIds: [labelId],
                removeLabelIds: ["INBOX"],
            },
        });
    } catch (err) {
        console.error("Error moving email to label:", err);
        throw err;
    }
}

// Create a raw email message
function makeRawEmail(userId, threadId, message) {
    const emailLines = [];

    emailLines.push(`From: ${userId}`);
    emailLines.push(`To: ${userId}`);
    emailLines.push('Content-Type: text/plain; charset="UTF-8"');
    emailLines.push("MIME-Version: 1.0");
    emailLines.push("Subject: Re: My Reply");
    emailLines.push(`In-Reply-To: <${threadId}>`);
    emailLines.push("");
    emailLines.push(message);

    const email = emailLines.join("\r\n");
    const encodedEmail = Buffer.from(email).toString("base64");
    return encodedEmail;
}


function checkEmailsWithRandomDelay() { // to handle check time to time
    const minDelay = 45 * 1000; 
    const maxDelay = 120 * 1000; 

    const randomDelay =
        Math.floor(Math.random() * (maxDelay - minDelay + 1)) + minDelay;
    console.log(`Next email check in ${randomDelay / 1000} seconds.`);

    setTimeout(async () => {
        await checkEmails();
        checkEmailsWithRandomDelay();
    }, randomDelay);
}

async function main() {
    try {
        await authorize();
        checkEmailsWithRandomDelay();
    } catch (err) {
        console.error("Error:", err);
    }
}

main();
